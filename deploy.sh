#!/bin/bash

# ScrappingBot Auto-Deployment Script
# Script de déploiement automatisé avec validation complète

set -e

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Icons
ROCKET="🚀"
CHECKMARK="✅"
ERROR="❌"
WARNING="⚠️"
GEAR="⚙️"

# Configuration
PROJECT_NAME="ScrappingBot"
DOCKER_COMPOSE_FILE="docker-compose.yml"
HEALTH_CHECK_TIMEOUT=120
DEPLOYMENT_MODE="production"

echo -e "${BLUE}$ROCKET $PROJECT_NAME - Déploiement automatisé${NC}"
echo "=================================================="

# Function to log messages
log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    
    case $level in
        "INFO")
            echo -e "${BLUE}[$timestamp] INFO:${NC} $message"
            ;;
        "SUCCESS")
            echo -e "${GREEN}[$timestamp] SUCCESS:${NC} $message"
            ;;
        "WARNING")
            echo -e "${YELLOW}[$timestamp] WARNING:${NC} $message"
            ;;
        "ERROR")
            echo -e "${RED}[$timestamp] ERROR:${NC} $message"
            ;;
    esac
}

# Function to check prerequisites
check_prerequisites() {
    log "INFO" "${GEAR} Vérification des prérequis..."
    
    # Check Docker
    if ! command -v docker >/dev/null 2>&1; then
        log "ERROR" "Docker n'est pas installé"
        exit 1
    fi
    
    # Check Docker Compose
    if ! command -v docker-compose >/dev/null 2>&1; then
        log "ERROR" "Docker Compose n'est pas installé"
        exit 1
    fi
    
    # Check if Docker daemon is running
    if ! docker info >/dev/null 2>&1; then
        log "ERROR" "Docker daemon n'est pas en cours d'exécution"
        exit 1
    fi
    
    # Check docker-compose.yml exists
    if [ ! -f "$DOCKER_COMPOSE_FILE" ]; then
        log "ERROR" "Fichier $DOCKER_COMPOSE_FILE non trouvé"
        exit 1
    fi
    
    # Check available disk space (need at least 5GB)
    available_space=$(df . | awk 'NR==2 {print $4}')
    required_space=5242880  # 5GB in KB
    
    if [ "$available_space" -lt "$required_space" ]; then
        log "WARNING" "Espace disque insuffisant (moins de 5GB disponible)"
    fi
    
    log "SUCCESS" "Tous les prérequis sont satisfaits"
}

# Function to create necessary directories
setup_directories() {
    log "INFO" "${GEAR} Création des répertoires nécessaires..."
    
    directories=(
        "logs"
        "data/raw"
        "data/processed"
        "data/backup"
        "docker/volumes/postgres"
        "docker/volumes/redis"
        "docker/volumes/grafana"
    )
    
    for dir in "${directories[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            log "INFO" "Répertoire créé: $dir"
        fi
    done
    
    log "SUCCESS" "Répertoires configurés"
}

# Function to check and create .env file
setup_environment() {
    log "INFO" "${GEAR} Configuration de l'environnement..."
    
    if [ ! -f ".env" ]; then
        log "INFO" "Création du fichier .env..."
        cat > .env << EOF
# Generated by auto-deploy script
# $(date)

# Database Configuration
POSTGRES_DB=scrappingbot
POSTGRES_USER=scrappingbot_user
POSTGRES_PASSWORD=$(openssl rand -hex 16)
POSTGRES_HOST=postgres
POSTGRES_PORT=5432

# Redis Configuration
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=

# API Configuration
API_HOST=0.0.0.0
API_PORT=8787
API_SECRET_KEY=$(openssl rand -hex 32)

# ETL Configuration
ETL_HOST=0.0.0.0
ETL_PORT=8788
ETL_BATCH_SIZE=1000

# Scraper Configuration
SCRAPER_USER_AGENT=ScrappingBot/1.0
SCRAPER_DELAY=1
SCRAPER_CONCURRENT_REQUESTS=16

# Logging
LOG_LEVEL=INFO
LOG_FORMAT=json

# Deployment
DEPLOYMENT_MODE=$DEPLOYMENT_MODE
COMPOSE_PROJECT_NAME=scrappingbot
EOF
        log "SUCCESS" "Fichier .env créé avec mots de passe sécurisés"
    else
        log "INFO" "Fichier .env existant trouvé"
    fi
}

# Function to validate docker-compose configuration
validate_compose() {
    log "INFO" "${GEAR} Validation de la configuration Docker Compose..."
    
    if docker-compose config >/dev/null 2>&1; then
        log "SUCCESS" "Configuration Docker Compose valide"
    else
        log "ERROR" "Configuration Docker Compose invalide"
        docker-compose config
        exit 1
    fi
}

# Function to pull base images
pull_images() {
    log "INFO" "${GEAR} Téléchargement des images de base..."
    
    base_images=(
        "postgres:15"
        "redis:7-alpine"
        "python:3.11"
        "node:18-alpine"
        "nginx:alpine"
        "grafana/grafana:latest"
    )
    
    for image in "${base_images[@]}"; do
        log "INFO" "Téléchargement de $image..."
        if docker pull "$image" >/dev/null 2>&1; then
            log "SUCCESS" "Image $image téléchargée"
        else
            log "WARNING" "Échec du téléchargement de $image"
        fi
    done
}

# Function to build application images
build_images() {
    log "INFO" "${GEAR} Construction des images de l'application..."
    
    if docker-compose build --parallel; then
        log "SUCCESS" "Toutes les images construites avec succès"
    else
        log "ERROR" "Échec de la construction des images"
        exit 1
    fi
}

# Function to stop existing containers
stop_existing() {
    log "INFO" "${GEAR} Arrêt des containers existants..."
    
    if docker-compose ps -q | grep -q .; then
        docker-compose down
        log "SUCCESS" "Containers existants arrêtés"
    else
        log "INFO" "Aucun container en cours d'exécution"
    fi
}

# Function to start services
start_services() {
    log "INFO" "${GEAR} Démarrage des services..."
    
    # Start database and cache first
    log "INFO" "Démarrage des services de données..."
    docker-compose up -d postgres redis
    sleep 10
    
    # Start processing services
    log "INFO" "Démarrage des services de traitement..."
    docker-compose up -d etl api
    sleep 10
    
    # Start web services
    log "INFO" "Démarrage des services web..."
    docker-compose up -d frontend chatbot
    sleep 5
    
    # Start monitoring services
    log "INFO" "Démarrage des services de monitoring..."
    docker-compose up -d grafana nginx
    sleep 5
    
    # Start remaining services
    log "INFO" "Démarrage des services restants..."
    docker-compose up -d
    
    log "SUCCESS" "Tous les services démarrés"
}

# Function to wait for services to be healthy
wait_for_health() {
    log "INFO" "${GEAR} Attente de la stabilisation des services..."
    
    local timeout=$HEALTH_CHECK_TIMEOUT
    local elapsed=0
    local interval=5
    
    services_to_check=("postgres" "redis" "etl" "api" "frontend")
    
    while [ $elapsed -lt $timeout ]; do
        all_healthy=true
        
        for service in "${services_to_check[@]}"; do
            if ! docker-compose ps "$service" | grep -q "Up"; then
                all_healthy=false
                break
            fi
        done
        
        if [ "$all_healthy" = true ]; then
            log "SUCCESS" "Tous les services sont opérationnels"
            return 0
        fi
        
        log "INFO" "Attente de la stabilisation... (${elapsed}s/${timeout}s)"
        sleep $interval
        elapsed=$((elapsed + interval))
    done
    
    log "WARNING" "Timeout atteint - certains services peuvent ne pas être prêts"
}

# Function to run health checks
run_health_checks() {
    log "INFO" "${GEAR} Exécution des vérifications de santé..."
    
    # Check if health script exists and run it
    if [ -f "scripts/health-check.sh" ]; then
        if ./scripts/health-check.sh; then
            log "SUCCESS" "Toutes les vérifications de santé passées"
        else
            log "WARNING" "Certaines vérifications de santé ont échoué"
        fi
    else
        # Manual basic checks
        log "INFO" "Vérifications de base..."
        
        # Check web endpoints
        if curl -sf http://localhost:3000 >/dev/null 2>&1; then
            log "SUCCESS" "Frontend accessible"
        else
            log "WARNING" "Frontend non accessible"
        fi
        
        if curl -sf http://localhost:8787/health >/dev/null 2>&1; then
            log "SUCCESS" "API accessible"
        else
            log "WARNING" "API non accessible"
        fi
        
        if curl -sf http://localhost:8788/health >/dev/null 2>&1; then
            log "SUCCESS" "ETL accessible"
        else
            log "WARNING" "ETL non accessible"
        fi
    fi
}

# Function to display deployment summary
show_deployment_summary() {
    log "INFO" "${CHECKMARK} Résumé du déploiement"
    echo ""
    echo -e "${GREEN}┌─ Services déployés ──────────────────────────────────────┐${NC}"
    echo -e "${GREEN}│${NC}"
    echo -e "${GREEN}│${NC} ${BLUE}Frontend:${NC}     http://localhost:3000"
    echo -e "${GREEN}│${NC} ${BLUE}API:${NC}          http://localhost:8787"
    echo -e "${GREEN}│${NC} ${BLUE}ETL:${NC}          http://localhost:8788" 
    echo -e "${GREEN}│${NC} ${BLUE}Chatbot:${NC}      http://localhost:8080"
    echo -e "${GREEN}│${NC} ${BLUE}Grafana:${NC}      http://localhost:3001 (admin/admin)"
    echo -e "${GREEN}│${NC}"
    echo -e "${GREEN}│${NC} ${PURPLE}PostgreSQL:${NC}   localhost:5432"
    echo -e "${GREEN}│${NC} ${PURPLE}Redis:${NC}        localhost:6379"
    echo -e "${GREEN}│${NC}"
    echo -e "${GREEN}└──────────────────────────────────────────────────────────┘${NC}"
    echo ""
    echo -e "${YELLOW}📝 Commandes utiles:${NC}"
    echo -e "  • Monitoring:        ${BLUE}./scripts/monitor.sh${NC}"
    echo -e "  • Logs:              ${BLUE}docker-compose logs -f${NC}"
    echo -e "  • Status:            ${BLUE}docker-compose ps${NC}"
    echo -e "  • Arrêt:             ${BLUE}docker-compose down${NC}"
    echo -e "  • Redémarrage:       ${BLUE}./deploy.sh${NC}"
    echo ""
}

# Function to setup monitoring dashboard
setup_monitoring() {
    log "INFO" "${GEAR} Configuration du monitoring..."
    
    # Create Grafana provisioning directories
    mkdir -p docker/volumes/grafana/provisioning/{dashboards,datasources}
    
    # Create basic datasource configuration
    cat > docker/volumes/grafana/provisioning/datasources/datasources.yml << EOF
apiVersion: 1

datasources:
  - name: PostgreSQL
    type: postgres
    url: postgres:5432
    database: scrappingbot
    user: scrappingbot_user
    secureJsonData:
      password: \${POSTGRES_PASSWORD}
    jsonData:
      sslmode: disable
      maxOpenConns: 100
      maxIdleConns: 100
      maxConnLifetimeMinutes: 1440
EOF
    
    log "SUCCESS" "Monitoring configuré"
}

# Function to cleanup on error
cleanup_on_error() {
    log "ERROR" "Erreur pendant le déploiement - nettoyage..."
    docker-compose down 2>/dev/null || true
    exit 1
}

# Function to handle script interruption
handle_interrupt() {
    log "WARNING" "Déploiement interrompu par l'utilisateur"
    cleanup_on_error
}

# Trap signals for cleanup
trap cleanup_on_error ERR
trap handle_interrupt INT TERM

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --mode)
            DEPLOYMENT_MODE="$2"
            shift 2
            ;;
        --timeout)
            HEALTH_CHECK_TIMEOUT="$2"
            shift 2
            ;;
        --help)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --mode MODE       Deployment mode (production, development)"
            echo "  --timeout SEC     Health check timeout in seconds"
            echo "  --help           Show this help"
            exit 0
            ;;
        *)
            log "ERROR" "Option inconnue: $1"
            exit 1
            ;;
    esac
done

# Main deployment flow
main() {
    local start_time=$(date +%s)
    
    log "INFO" "${ROCKET} Début du déploiement en mode $DEPLOYMENT_MODE"
    
    # Phase 1: Prerequisites and setup
    check_prerequisites
    setup_directories
    setup_environment
    validate_compose
    
    # Phase 2: Images
    pull_images
    build_images
    
    # Phase 3: Deployment
    stop_existing
    setup_monitoring
    start_services
    
    # Phase 4: Validation
    wait_for_health
    run_health_checks
    
    # Phase 5: Summary
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    log "SUCCESS" "Déploiement terminé en ${duration}s"
    show_deployment_summary
}

# Execute main function
main "$@"
